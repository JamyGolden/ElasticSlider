/**
 * ElasticSlider - An agnostic and responsive slider.
 * @version v0.0.1
 * @link 
 * @license MIT
 */
// ============================================================================
// ElasticSlider Pagination Item
// Polymer element used within ElasticSlider
// Version: "0.0.1"
// Jamy Golden (http://css-plus.com/)
// https://github.com/JamyGolden/ElasticSlider
// License: MIT
// ============================================================================

'use strict';

(function () {
    'use strict';

    Polymer({
        is: 'elastic-slider-pagi-item',
        properties: {
            model: {
                type: Object,
                value: function value() {
                    return {};
                }
            },
            activeSlide: {
                type: Number,
                notify: true,
                value: 0
            },
            isDisabled: {
                type: Boolean,
                value: function value() {
                    return false;
                }
            }
        },
        setActive: function setActive() {
            if (this.isDisabled === false) {
                this.activeSlide = this.model.index + 1;
            }
        },
        getClassList: function getClassList(activeSlide) {
            var classList = 'ElasticSlider-pagiItem';

            if (this.model.index === activeSlide - 1) classList += ' ElasticSlider-pagiItem--isActive';

            return classList;
        }
    });
})();
// ============================================================================
// ElasticSlider
// Description still needed.
// Version: "0.0.1"
// Jamy Golden (http://css-plus.com/)
// https://github.com/JamyGolden/ElasticSlider
// License: MIT
// ============================================================================
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var ElasticSlider = (function () {
    function ElasticSlider(el, options) {
        _classCallCheck(this, ElasticSlider);

        // Public properties
        // ====================================================================
        this.NAMESPACE = 'ElasticSlider';
        this.CLASS_NAME_LIST = {
            'container': this.NAMESPACE + '-container',
            'item': this.NAMESPACE + '-item',
            'itemActive': this.NAMESPACE + '-item--isActive',
            'itemClone': this.NAMESPACE + '-item--clone'
        };
        this.options = this._filterOptions(options);
        this.properties = {};
        this.setProp('activeSlideIndex', this.options.activeSlide - 1);
        this.setProp('nextActiveSlideIndex', this.options.activeSlide);
        this.setProp('isAnimating', false);

        // Private properties
        // ====================================================================
        this._animationFunctionHash = {};
        this._slideCount = null;
        this._initialAnimationDelay = 50; // ms in which animation begins
        this._startAnimationUserCallback = function () {};
        this._endAnimationUserCallback = function () {};

        // Create animations
        // ====================================================================
        this._createAnimationFunctions();

        // Elements
        // ====================================================================
        this.elementList = {};
        this.elementList.slider = el;
        this.elementList.containerEl = this.elementList.slider.querySelector('.' + this.CLASS_NAME_LIST.container);
        this.elementList.slideArr = this.elementList.containerEl.children;
        this.elementList.slideActiveEl = this.elementList.slideArr[options.activeSlide - 1];
        this.elementList.cloneEl = null;
        this._slideCount = this.elementList.slideArr.length;

        // DOM manipulation
        // ====================================================================
        this.elementList.slider.classList.add(this.NAMESPACE);

        for (var i = 0; i < this.elementList.slideArr.length; i++) {
            var itemEl = this.elementList.slideArr[i];

            itemEl.classList.add(this.CLASS_NAME_LIST.item);
        }

        this._setActiveSlide(this.getProp('activeSlideIndex'));

        this._addCustomAnimationFunctions();
    }

    // ====================================================================
    // Public methods
    // ====================================================================
    // May be useful in future. No events to remove.

    _createClass(ElasticSlider, [{
        key: 'destroy',
        value: function destroy() {
            this.elementList.containerEl.removeChild(this.elementList.cloneEl);
        }
    }, {
        key: 'toSlide',
        value: function toSlide(params) {
            // Forces invalid property checks to return undefined
            params = params || {};

            var index = params.index;
            var animateType = params.animate || this.options.animation;
            var startAnimationCallback = params.startAnimationCallback;
            var endAnimationCallback = params.endAnimationCallback;

            // Don't animate to the same slide
            // Don't animate while animating
            if (index === this.getProp('activeSlideIndex') || this.getProp('isAnimating') === true) {
                return;
            };

            // Handle invalid index values
            if (typeof index !== 'number' || index > this._slideCount - 1) {
                index = 0;
            } else if (index < 0) {
                index = this._slideCount - 1;
            };

            this._createTransitionEl(index);
            this.setProp('nextActiveSlideIndex', index);
            this.setProp('isAnimating', true);

            // Set callback animations
            if (typeof startAnimationCallback === 'function') {
                this._startAnimationUserCallback = startAnimationCallback;
            }

            if (typeof endAnimationCallback === 'function') {
                this._endAnimationUserCallback = endAnimationCallback;
            }

            if (animateType) {
                this._startAnimationUserCallback();
                this._animationFunctionHash[animateType](this, index + 1);
            } else {
                this._endSlide(index);
            }
        }
    }, {
        key: 'animationInit',
        value: function animationInit(cb) {
            if (typeof cb === 'function') {
                // Run the method in context of the class
                cb = cb.bind(this);
                cb();
            }
        }
    }, {
        key: 'animationStart',
        value: function animationStart(cb) {
            var self = this;

            // Defer
            window.setTimeout(function () {
                if (typeof cb === 'function') {
                    // Run the method in context of the class
                    cb = cb.bind(self);
                    cb();
                }
            }, this._initialAnimationDelay);
        }
    }, {
        key: 'animationEnd',
        value: function animationEnd(duration, cb) {
            var self = this;
            var totalDuration = (duration || 100) + this._initialAnimationDelay;

            window.setTimeout(function () {
                if (typeof cb === 'function') {
                    // Run the method in context of the class
                    cb = cb.bind(self);
                    cb();
                }

                self._endSlide();
            }, totalDuration);
        }
    }, {
        key: 'addAnimationFunction',
        value: function addAnimationFunction(name, func) {
            this._animationFunctionHash[name] = func.bind(this);
        }
    }, {
        key: 'getElement',
        value: function getElement(elName) {
            return this.elementList[elName];
        }
    }, {
        key: 'getProp',
        value: function getProp(propName) {
            return this.properties[propName];
        }
    }, {
        key: 'setProp',
        value: function setProp(propName, val) {
            this.properties[propName] = val;
        }
    }, {
        key: 'removeProp',
        value: function removeProp(propName, val) {
            delete this.properties[propName];
        }

        // ====================================================================
        // Private methods
        // ====================================================================

    }, {
        key: '_filterOptions',
        value: function _filterOptions(o) {
            if (!o.activeSlide) o.activeSlide = 0;
            if (!o.animation) o.animation = 'slide';

            return o;
        }
    }, {
        key: '_endSlide',
        value: function _endSlide() {
            this._setActiveSlide();
            this.setProp('isAnimating', false);

            // Remove clone
            this.elementList.containerEl.removeChild(this.elementList.cloneEl);
            this.elementList.cloneEl = null;

            // `toSlide` callback
            this._endAnimationUserCallback();

            // Reset callbacks
            this._startAnimationUserCallback = function () {};
            this._endAnimationUserCallback = function () {};
        }
    }, {
        key: '_setActiveSlide',
        value: function _setActiveSlide(index) {
            // Use slide pased in or the next slide
            if (!index) index = this.getProp('nextActiveSlideIndex');

            // Remove the active class name from all elements
            for (var i = 0; i < this.elementList.slideArr.length; i++) {
                var slide = this.elementList.slideArr[i];

                slide.classList.remove(this.CLASS_NAME_LIST.itemActive);
            }

            this.elementList.slideActiveEl = this.elementList.slideArr[index];
            this.elementList.slideActiveEl.classList.add(this.CLASS_NAME_LIST.itemActive);
            // Set active index and remove target item active index
            this.setProp('activeSlideIndex', index);
            this.setProp('nextActiveSlideIndex', null);
        }
    }, {
        key: '_createTransitionEl',
        value: function _createTransitionEl(index) {
            if (this.elementList.cloneEl) {
                this.elementList.containerEl.removeChild(this.elementList.cloneEl);
            }

            // Create el
            this.elementList.cloneEl = this.elementList.slideArr[index].cloneNode(true);
            this.elementList.cloneEl.classList.add(this.CLASS_NAME_LIST.itemClone);

            // Add to dom
            this.elementList.containerEl.appendChild(this.elementList.cloneEl);
        }

        // Animations. These are the default animations. Any extra animations
        // should be added via the external add method
    }, {
        key: '_createAnimationFunctions',
        value: function _createAnimationFunctions() {
            this.addAnimationFunction('fade', function () {
                this.animationInit(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animateFadeInit');
                });

                this.animationStart(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animateFadeStart');
                });

                this.animationEnd(600);
            });

            this.addAnimationFunction('slide', function () {
                var direction = null; // Determines which direction to slide
                var animationDirection = this.getProp('animationDirection');

                // If an explicit direction has been set
                if (animationDirection) {
                    direction = animationDirection;
                }
                // Otherwise greater index means next
                else if (this.getProp('nextActiveSlideIndex') > this.getProp('activeSlideIndex')) {
                        direction = 'Next';
                    } else {
                        direction = 'Prev';
                    };

                this.animationInit(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animate' + direction + 'SlideInit');
                    this.elementList.slideActiveEl.classList.add(this.NAMESPACE + '-item--animateActive' + direction + 'SlideInit');
                });

                this.animationStart(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animate' + direction + 'SlideStart');
                    this.elementList.slideActiveEl.classList.add(this.NAMESPACE + '-item--animateActive' + direction + 'SlideStart');
                });

                this.animationEnd(1000, function () {
                    this.elementList.slideActiveEl.classList.remove(this.NAMESPACE + '-item--animateActive' + direction + 'SlideInit');
                    this.elementList.slideActiveEl.classList.remove(this.NAMESPACE + '-item--animateActive' + direction + 'SlideStart');

                    // Don't allow this to be cached permanently
                    this.removeProp('animationDirection');
                });
            });
        }

        // Allows for animations functions to be inserted from an external source
    }, {
        key: '_addCustomAnimationFunctions',
        value: function _addCustomAnimationFunctions() {
            var customAnimationMap = window.elasticSliderAnimationMap;

            if (typeof customAnimationMap === 'object') {
                for (var _name in customAnimationMap) {
                    this.addAnimationFunction(_name, customAnimationMap[_name]);
                }
            }
        }
    }]);

    return ElasticSlider;
})();
// ============================================================================
// ElasticSlider
// Description still needed.
// Version: "0.0.1"
// Jamy Golden (http://css-plus.com/)
// https://github.com/JamyGolden/ElasticSlider
// License: MIT
// ============================================================================
'use strict';

var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
})();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}

var ElasticSlider = (function () {
    function ElasticSlider(el, options) {
        _classCallCheck(this, ElasticSlider);

        // Public properties
        // ====================================================================
        this.NAMESPACE = 'ElasticSlider';
        this.CLASS_NAME_LIST = {
            'container': this.NAMESPACE + '-container',
            'item': this.NAMESPACE + '-item',
            'itemActive': this.NAMESPACE + '-item--isActive',
            'itemClone': this.NAMESPACE + '-item--clone'
        };
        this.options = this._filterOptions(options);
        this.properties = {};
        this.setProp('activeSlideIndex', this.options.activeSlide - 1);
        this.setProp('nextActiveSlideIndex', this.options.activeSlide);
        this.setProp('isAnimating', false);

        // Private properties
        // ====================================================================
        this._animationFunctionHash = {};
        this._slideCount = null;
        this._initialAnimationDelay = 50; // ms in which animation begins
        this._startAnimationUserCallback = function () {};
        this._endAnimationUserCallback = function () {};

        // Create animations
        // ====================================================================
        this._createAnimationFunctions();

        // Elements
        // ====================================================================
        this.elementList = {};
        this.elementList.slider = el;
        this.elementList.containerEl = this.elementList.slider.querySelector('.' + this.CLASS_NAME_LIST.container);
        this.elementList.slideArr = this.elementList.containerEl.children;
        this.elementList.slideActiveEl = this.elementList.slideArr[options.activeSlide - 1];
        this.elementList.cloneEl = null;
        this._slideCount = this.elementList.slideArr.length;

        // DOM manipulation
        // ====================================================================
        this.elementList.slider.classList.add(this.NAMESPACE);

        for (var i = 0; i < this.elementList.slideArr.length; i++) {
            var itemEl = this.elementList.slideArr[i];

            itemEl.classList.add(this.CLASS_NAME_LIST.item);
        }

        this._setActiveSlide(this.getProp('activeSlideIndex'));

        this._addCustomAnimationFunctions();
    }

    // ====================================================================
    // Public methods
    // ====================================================================
    // May be useful in future. No events to remove.

    _createClass(ElasticSlider, [{
        key: 'destroy',
        value: function destroy() {
            this.elementList.containerEl.removeChild(this.elementList.cloneEl);
        }
    }, {
        key: 'toSlide',
        value: function toSlide(params) {
            // Forces invalid property checks to return undefined
            params = params || {};

            var index = params.index;
            var animateType = params.animate || this.options.animation;
            var startAnimationCallback = params.startAnimationCallback;
            var endAnimationCallback = params.endAnimationCallback;

            // Don't animate to the same slide
            // Don't animate while animating
            if (index === this.getProp('activeSlideIndex') || this.getProp('isAnimating') === true) {
                return;
            };

            // Handle invalid index values
            if (typeof index !== 'number' || index > this._slideCount - 1) {
                index = 0;
            } else if (index < 0) {
                index = this._slideCount - 1;
            };

            this._createTransitionEl(index);
            this.setProp('nextActiveSlideIndex', index);
            this.setProp('isAnimating', true);

            // Set callback animations
            if (typeof startAnimationCallback === 'function') {
                this._startAnimationUserCallback = startAnimationCallback;
            }

            if (typeof endAnimationCallback === 'function') {
                this._endAnimationUserCallback = endAnimationCallback;
            }

            if (animateType) {
                this._startAnimationUserCallback();
                this._animationFunctionHash[animateType](this, index + 1);
            } else {
                this._endSlide(index);
            }
        }
    }, {
        key: 'animationInit',
        value: function animationInit(cb) {
            if (typeof cb === 'function') {
                // Run the method in context of the class
                cb = cb.bind(this);
                cb();
            }
        }
    }, {
        key: 'animationStart',
        value: function animationStart(cb) {
            var self = this;

            // Defer
            window.setTimeout(function () {
                if (typeof cb === 'function') {
                    // Run the method in context of the class
                    cb = cb.bind(self);
                    cb();
                }
            }, this._initialAnimationDelay);
        }
    }, {
        key: 'animationEnd',
        value: function animationEnd(duration, cb) {
            var self = this;
            var totalDuration = (duration || 100) + this._initialAnimationDelay;

            window.setTimeout(function () {
                if (typeof cb === 'function') {
                    // Run the method in context of the class
                    cb = cb.bind(self);
                    cb();
                }

                self._endSlide();
            }, totalDuration);
        }
    }, {
        key: 'addAnimationFunction',
        value: function addAnimationFunction(name, func) {
            this._animationFunctionHash[name] = func.bind(this);
        }
    }, {
        key: 'getElement',
        value: function getElement(elName) {
            return this.elementList[elName];
        }
    }, {
        key: 'getProp',
        value: function getProp(propName) {
            return this.properties[propName];
        }
    }, {
        key: 'setProp',
        value: function setProp(propName, val) {
            this.properties[propName] = val;
        }
    }, {
        key: 'removeProp',
        value: function removeProp(propName, val) {
            delete this.properties[propName];
        }

        // ====================================================================
        // Private methods
        // ====================================================================

    }, {
        key: '_filterOptions',
        value: function _filterOptions(o) {
            if (!o.activeSlide) o.activeSlide = 0;
            if (!o.animation) o.animation = 'slide';

            return o;
        }
    }, {
        key: '_endSlide',
        value: function _endSlide() {
            this._setActiveSlide();
            this.setProp('isAnimating', false);

            // Remove clone
            this.elementList.containerEl.removeChild(this.elementList.cloneEl);
            this.elementList.cloneEl = null;

            // `toSlide` callback
            this._endAnimationUserCallback();

            // Reset callbacks
            this._startAnimationUserCallback = function () {};
            this._endAnimationUserCallback = function () {};
        }
    }, {
        key: '_setActiveSlide',
        value: function _setActiveSlide(index) {
            // Use slide pased in or the next slide
            if (!index) index = this.getProp('nextActiveSlideIndex');

            // Remove the active class name from all elements
            for (var i = 0; i < this.elementList.slideArr.length; i++) {
                var slide = this.elementList.slideArr[i];

                slide.classList.remove(this.CLASS_NAME_LIST.itemActive);
            }

            this.elementList.slideActiveEl = this.elementList.slideArr[index];
            this.elementList.slideActiveEl.classList.add(this.CLASS_NAME_LIST.itemActive);
            // Set active index and remove target item active index
            this.setProp('activeSlideIndex', index);
            this.setProp('nextActiveSlideIndex', null);
        }
    }, {
        key: '_createTransitionEl',
        value: function _createTransitionEl(index) {
            if (this.elementList.cloneEl) {
                this.elementList.containerEl.removeChild(this.elementList.cloneEl);
            }

            // Create el
            this.elementList.cloneEl = this.elementList.slideArr[index].cloneNode(true);
            this.elementList.cloneEl.classList.add(this.CLASS_NAME_LIST.itemClone);

            // Add to dom
            this.elementList.containerEl.appendChild(this.elementList.cloneEl);
        }

        // Animations. These are the default animations. Any extra animations
        // should be added via the external add method
    }, {
        key: '_createAnimationFunctions',
        value: function _createAnimationFunctions() {
            this.addAnimationFunction('fade', function () {
                this.animationInit(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animateFadeInit');
                });

                this.animationStart(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animateFadeStart');
                });

                this.animationEnd(600);
            });

            this.addAnimationFunction('slide', function () {
                var direction = null; // Determines which direction to slide
                var animationDirection = this.getProp('animationDirection');

                // If an explicit direction has been set
                if (animationDirection) {
                    direction = animationDirection;
                }
                // Otherwise greater index means next
                else if (this.getProp('nextActiveSlideIndex') > this.getProp('activeSlideIndex')) {
                        direction = 'Next';
                    } else {
                        direction = 'Prev';
                    };

                this.animationInit(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animate' + direction + 'SlideInit');
                    this.elementList.slideActiveEl.classList.add(this.NAMESPACE + '-item--animateActive' + direction + 'SlideInit');
                });

                this.animationStart(function () {
                    this.elementList.cloneEl.classList.add(this.NAMESPACE + '-item--animate' + direction + 'SlideStart');
                    this.elementList.slideActiveEl.classList.add(this.NAMESPACE + '-item--animateActive' + direction + 'SlideStart');
                });

                this.animationEnd(1000, function () {
                    this.elementList.slideActiveEl.classList.remove(this.NAMESPACE + '-item--animateActive' + direction + 'SlideInit');
                    this.elementList.slideActiveEl.classList.remove(this.NAMESPACE + '-item--animateActive' + direction + 'SlideStart');

                    // Don't allow this to be cached permanently
                    this.removeProp('animationDirection');
                });
            });
        }

        // Allows for animations functions to be inserted from an external source
    }, {
        key: '_addCustomAnimationFunctions',
        value: function _addCustomAnimationFunctions() {
            var customAnimationMap = window.elasticSliderAnimationMap;

            if (typeof customAnimationMap === 'object') {
                for (var _name in customAnimationMap) {
                    this.addAnimationFunction(_name, customAnimationMap[_name]);
                }
            }
        }
    }]);

    return ElasticSlider;
})();
//# sourceMappingURL=elasticslider.min.js.map
// ============================================================================
// ElasticSlider
// Description still needed.
// Jamy Golden (http://css-plus.com/)
// https://github.com/JamyGolden/ElasticSlider
// License: MIT
// ============================================================================

'use strict';

(function () {
    'use strict';

    Polymer({
        is: 'elastic-slider',
        properties: {
            activeSlide: {
                type: Number,
                value: 1
            },

            enableArrows: {
                type: Boolean
            },

            enablePagination: {
                type: Boolean
            },

            autoPlayDuration: {
                type: Number,
                value: 0
            },

            animation: {
                type: String,
                value: 'slide'
            }
        },

        observers: ['updatePagi(activeSlide)'],

        updatePagi: function updatePagi(itemNum) {
            if (!this.slider) return; // This triggers on init

            this.toSlide(itemNum - 1);
        },

        clickToSlide: function clickToSlide(e) {
            var val = e.model.item;
            var index = undefined;

            // Determine next slide index
            if (typeof val === 'number') {
                index = val - 1;
            } else if (val === 'Prev') {
                index = this.slider.getProp('activeSlideIndex') - 1;

                this.slider.setProp('animationDirection', 'Prev');
            } else {
                index = this.slider.getProp('activeSlideIndex') + 1;

                this.slider.setProp('animationDirection', 'Next');
            }

            index = this._getTargetIndex(index);

            this.toSlide(index);
        },

        toSlide: function toSlide(index) {
            var self = this;

            this.disablePagi = true;
            // Go to slide, once done, set active

            this.slider.toSlide({
                index: index,
                animation: this.animation,
                startAnimationCallback: function startAnimationCallback() {
                    self.activeSlide = index + 1;
                },
                endAnimationCallback: function endAnimationCallback() {
                    self.disablePagi = false;
                }
            });

            // Reset autoPlay interval
            if (this.autoPlayDuration > 0) {
                this.stopAutoPlay();
                this.startAutoPlay();
            }
        },

        ready: function ready() {
            var sliderOptions = {
                activeSlide: this.activeSlide,
                animation: this.animation
            };

            // Get range array of slides for pagination
            this.autoPlayInterval = null;
            this.pagiArr = [];
            this.totalSlides = this.querySelector('.ElasticSlider-container').children.length;
            this.arrowArr = ['Prev', 'Next'];
            this.disablePagi = false;

            // Init slider
            this.pagiArr = this._pagiFactory(this.totalSlides);
            this.slider = new ElasticSlider(this, sliderOptions);

            if (this.autoPlayDuration > 0) {
                this.startAutoPlay();
            }
        },

        startAutoPlay: function startAutoPlay() {
            var self = this;

            // If autoPlay is set
            this.autoPlayInterval = window.setInterval(function () {
                var index = self._getTargetIndex(self.slider.getProp('activeSlideIndex') + 1);

                // Set direction
                self.slider.setProp('animationDirection', 'Next');

                self.toSlide(index);
            }, this.autoPlayDuration);
        },

        stopAutoPlay: function stopAutoPlay() {
            window.clearInterval(this.autoPlayInterval);
        },

        _pagiFactory: function _pagiFactory(num) {
            var arr = [];

            for (var i = 0; i < num; i++) {
                arr.push({
                    index: i,
                    isActive: self.activeSlide - 1 === i,
                    type: 'pagi'
                });
            }

            return arr;
        },

        _getTargetIndex: function _getTargetIndex(num) {
            if (num < 0) {
                num = this.totalSlides - 1;
            } else if (num > this.totalSlides - 1) {
                num = 0;
            }

            return num;
        }
    });
})();
// ============================================================================
// ElasticSlider
// Description still needed.
// Jamy Golden (http://css-plus.com/)
// https://github.com/JamyGolden/ElasticSlider
// License: MIT
// ============================================================================

'use strict';

(function () {
    'use strict';

    Polymer({
        is: 'elastic-slider',
        properties: {
            activeSlide: {
                type: Number,
                value: 1
            },

            enableArrows: {
                type: Boolean
            },

            enablePagination: {
                type: Boolean
            },

            autoPlayDuration: {
                type: Number,
                value: 0
            },

            animation: {
                type: String,
                value: 'slide'
            }
        },

        observers: ['updatePagi(activeSlide)'],

        updatePagi: function updatePagi(itemNum) {
            if (!this.slider) return; // This triggers on init

            this.toSlide(itemNum - 1);
        },

        clickToSlide: function clickToSlide(e) {
            var val = e.model.item;
            var index = undefined;

            // Determine next slide index
            if (typeof val === 'number') {
                index = val - 1;
            } else if (val === 'Prev') {
                index = this.slider.getProp('activeSlideIndex') - 1;

                this.slider.setProp('animationDirection', 'Prev');
            } else {
                index = this.slider.getProp('activeSlideIndex') + 1;

                this.slider.setProp('animationDirection', 'Next');
            }

            index = this._getTargetIndex(index);

            this.toSlide(index);
        },

        toSlide: function toSlide(index) {
            var self = this;

            this.disablePagi = true;
            // Go to slide, once done, set active

            this.slider.toSlide({
                index: index,
                animation: this.animation,
                startAnimationCallback: function startAnimationCallback() {
                    self.activeSlide = index + 1;
                },
                endAnimationCallback: function endAnimationCallback() {
                    self.disablePagi = false;
                }
            });

            // Reset autoPlay interval
            if (this.autoPlayDuration > 0) {
                this.stopAutoPlay();
                this.startAutoPlay();
            }
        },

        ready: function ready() {
            var sliderOptions = {
                activeSlide: this.activeSlide,
                animation: this.animation
            };

            // Get range array of slides for pagination
            this.autoPlayInterval = null;
            this.pagiArr = [];
            this.totalSlides = this.querySelector('.ElasticSlider-container').children.length;
            this.arrowArr = ['Prev', 'Next'];
            this.disablePagi = false;

            // Init slider
            this.pagiArr = this._pagiFactory(this.totalSlides);
            this.slider = new ElasticSlider(this, sliderOptions);

            if (this.autoPlayDuration > 0) {
                this.startAutoPlay();
            }
        },

        startAutoPlay: function startAutoPlay() {
            var self = this;

            // If autoPlay is set
            this.autoPlayInterval = window.setInterval(function () {
                var index = self._getTargetIndex(self.slider.getProp('activeSlideIndex') + 1);

                // Set direction
                self.slider.setProp('animationDirection', 'Next');

                self.toSlide(index);
            }, this.autoPlayDuration);
        },

        stopAutoPlay: function stopAutoPlay() {
            window.clearInterval(this.autoPlayInterval);
        },

        _pagiFactory: function _pagiFactory(num) {
            var arr = [];

            for (var i = 0; i < num; i++) {
                arr.push({
                    index: i,
                    isActive: self.activeSlide - 1 === i,
                    type: 'pagi'
                });
            }

            return arr;
        },

        _getTargetIndex: function _getTargetIndex(num) {
            if (num < 0) {
                num = this.totalSlides - 1;
            } else if (num > this.totalSlides - 1) {
                num = 0;
            }

            return num;
        }
    });
})();
//# sourceMappingURL=polymer-elasticslider.min.js.map